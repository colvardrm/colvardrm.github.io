---
layout: post	
title: Erlang Workers
---

First of all, if you haven't looked up the resources available for Erlang already, I would seriously recommend [Learn You Some Erlang for Great Good!](http://learnyousomeerlang.com/). It's a great resource for getting started with Erlang, and I would recommend reading that before practically anything else on it. Now, onto the main topic.

Erlang uses what is called the Actor Model. This is a model that is very good at handling concurrent programming, and it involves making processes that send messages to each other. Processes are very cheap to spawn in Erlang, and for some applications, it can be practical to have thousands of them going at once. These processes are independent from each other, and as a result don't share any state between them. They don't have access to each other's variables. If you know the process ID of a process, you can send messages to it using the '!' operator.

Erlang's model and the use of the Open Telecom Platform (OTP), a set of very well-tested libraries with decades of use behind them, encourage a certain structure to your programs. This structure is actually where Erlang's high reliability comes from. Individual Erlang programs have a real tendency to crash when they get something unexpected, but this isn't a bad thing. Processes called supervisors, which stay away from areas of uncertainty, will restart programs they are supervising that have crashed. There are different policies for restarting and the "leniency" of the supervisor before the supervisor itself will shut down, but I'd recommend the resource I've linked to go more deeply into the details. As a basic overview, you can adjust how dependent the child processes are on each other, how many times a child process can crash in a certain amount of time before the supervisor gives up, and how to handle an individual child process ending. The dependency of children can be, for example, restarting all the child processes if one crashes, or only restarting the one that crashed. Adjusting the handling for individual child processes will allow the supervisor to make children that, for example, restart only when they crash, and not when they successfully execute. [Learn You Some Erlang's supervisor section](http://learnyousomeerlang.com/supervisors) is very helpful for this.

Supervisors shouldn't really execute code of their own typically - that's the job of workers. Peronally, I'd add an unofficial sub-tier to workers as well (maybe called interns, or freelancers) that just execute code that you don't want the worker doing itself. Things that can hold the process up, like querying a database or setting up a socket connection, for example. These are often best handled by spawning in another worker, having them do the work, messaging the result back to the parent process, and then ending. Erlang's spawn function allows you to do exactly this, as it will spawn a process that runs a single function that you specify, then end the process.
